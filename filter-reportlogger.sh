#!/bin/ksh
#
# OpenSMTPD filter (smtpd-filters(7)) to log report events.

set -e

DEFAULT_LOG_LEVEL="info"

set -A REGISTER_LINES -- \
	"register|report|smtp-in|link-connect" \
	"register|report|smtp-in|link-identify" \
	"register|report|smtp-in|link-disconnect" \
	"register|report|smtp-in|link-auth" \
	"register|report|smtp-in|timeout" \
	"register|ready"

PROGNAME="$(basename "$0")"


# Show help output.
#
show_usage()
{
	cat <<-EOF
	Log report events from smtpd(8).

	USAGE: $PROGNAME [options]
	  -o <outfile>: write received events to the specified output file
	  -t: write received events to an autogenerated temporary file
	  -d: enable debug logging level
EOF
}


# Output log message to stdout (resulting in logging via smtpd(8)).
#
# LVL: log level for message.
# MSG: message to log.
#
# There are three log levels:
# - error: error logs are always logged.
# - info: info logging is the default and are effectively always logged.
# - debug: debug logging is not logged by default but can be enabled with a
#   command line option.
#
emit_log()
{
	_LVL="$1"
	_MSG="$2"
	case "$_LVL" in
		error|info|debug) : ;;
		*)
			emit_log error "invalid log level ($_LVL) specified (exiting)"
			return 2
			;;
	esac

	if [ "$LOG_LEVEL" = "$_LVL" ] || [ "$LOG_LEVEL" = "debug" ] || [ "$_LVL" = "error" ]
	then
		echo "$_LVL: $_MSG" >&2
	fi
}


# Report stats of lines that were output.
#
report_output()
{
	[ $LOG_COUNT -eq 1 ] && _SUF="" || _SUF="s"
	emit_log info "wrote $LOG_COUNT event${_SUF} to output"
	# Explicit exit to terminate program immediately so report is only
	# output once.
	exit 0
}


# Process input event stream and write to specified output file.
# 
# OUTFILE: writable output file.
#
process_stream_to_output()
{
	OUTFILE="$1"
	LOG_COUNT=0
	emit_log info "writing events from stdin to $OUTFILE"
	while read -r line
	do
		echo "$line" >> "$OUTFILE"
		((LOG_COUNT += 1))
		emit_log debug "received line >>$line<<"
		if echo "$line" | grep -F -q "config|ready"
		then
			emit_log debug "configuration received from smtpd (ready to process events)"
			for out_line in "${REGISTER_LINES[@]}"
			do
				echo "$out_line"
				emit_log debug "wrote the ${out_line} line to smtpd on stdout"
			done
		fi
	done
}

# Parse arguments
while getopts "o:tdh" OPTCHAR; do
	case "$OPTCHAR" in
	  o)  OPT_OUTFILE="$OPTARG" ;;
	  t)  LOG_TO_TEMPFILE=1     ;;
	  d)  OPT_LOG_LEVEL="debug" ;;
	  h)  show_usage; exit 0    ;;
	  *)  show_usage; exit 1    ;;
	esac
done
shift $((OPTIND - 1))

LOG_LEVEL="${OPT_LOG_LEVEL:-$DEFAULT_LOG_LEVEL}"
emit_log debug "after parsing options, LOG_LEVEL is $LOG_LEVEL"

# Ensure that one of the output file options has been set
if [ -z "$OPT_OUTFILE"  ] && [ -z "$LOG_TO_TEMPFILE" ]
then
	emit_log error "at least one output option must be set (exiting)"
	exit 2
fi

# Set output file path accordingly
if [ -n "$LOG_TO_TEMPFILE" ]
then
	OUTFILE="$(mktemp -t "${PROGNAME%.*}-XXXXXXXX")"
else
	OUTFILE="$OPT_OUTFILE"
fi

# If program is terminated, output count stat when exiting.
trap report_output EXIT ERR

process_stream_to_output "$OUTFILE"
